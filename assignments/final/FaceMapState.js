
class FaceMapState {
  constructor(predictions, fireworks) {
    this.predictions = predictions; // Store the passed predictions
    this.fireworks = fireworks;
  }



  draw() {

    // fireworks
    // Draw fireworks
    for (let i = 0; i < this.fireworks.length; i++) {
      this.fireworks[i].update();
      this.fireworks[i].draw();
      if (this.fireworks[i].alpha <= 0) {
        this.fireworks.splice(i, 1);
      }
    }
    // end of fireworks

    background("#00000030");

    // Access face mesh data and draw based on predictions 
    if (predictions && predictions.length > 0) {
      for (let i = 0; i < predictions.length; i += 1) {
        const keypoints = predictions[i].scaledMesh;
        // Draw facial features using keypoints (circles)
        for (let j = 0; j < keypoints.length; j += 1) {
          const [x, y] = keypoints[j];
          fill(255, 0, 0);
          noStroke();
          ellipse(x, y, 5, 5);
        }
      }
    } else {
      // Handle the case where no predictions are available 
      // Case for if face goes out of frame
      fill(255);
      textSize(20);
      text("No face detected", width / 2, height / 2);
    }

    fill(244);
    text("Face Map State", 200, 100);

    // video.show();  // This line shows the video when in FaceMapState
  }



  mousePressed() {
    currentState = faceMapState; // should be particleSymphony
  }
}

// Fireworks
class Firework {
  constructor(x, y, color) {
      this.pos = createVector(x, y);
      this.vel = createVector(random(-1, 1), random(-5, -1));
      this.acc = createVector(0, 0.1);
      this.color = color;
      this.size = 10;
      this.alpha = 255;
      // Flag to track if the firework has exploded
      this.exploded = false; 
      // Store particles
      this.particles = []; 
  }

  // If the firework hasn't yet exploded, show particle moving upwards on canvas with trail
  update() {
      if (!this.exploded) {
          this.vel.add(this.acc);
          this.pos.add(this.vel);
          if (this.vel.y >= 0) {
              this.explode();
          }
      } else {
          for (let i = this.particles.length - 1; i >= 0; i--) {
              this.particles[i].update();
              if (this.particles[i].alpha <= 0) {
                  this.particles.splice(i, 1);
              }
          }
      }
  }

  draw() {
      if (!this.exploded) {
          noStroke();
          fill(this.color[0], this.color[1], this.color[2], this.alpha);
          ellipse(this.pos.x, this.pos.y, this.size, this.size);
      } else {
          for (let i = 0; i < this.particles.length; i++) {
              this.particles[i].draw();
          }
      }
  }

  // Explosion effect crates multiple particles from the original one displayed on screen.
  // Uses random() function to create different colors
  // Generated by ChatGPT
  explode() {
      this.exploded = true;
      for (let i = 0; i < 100; i++) {
          const particleVel = p5.Vector.random2D().mult(random(1, 5));
          const particleColor = [random(255), random(255), random(255)];
          this.particles.push(new Particle(this.pos.x, this.pos.y, particleVel, particleColor));
      }
  }
  // end of ChatGPT generation
}

// Individual Particles
class Particle {
  constructor(x, y, vel, color) {
      this.pos = createVector(x, y);
      this.vel = vel;
      this.acc = createVector(0, 0.1);
      this.color = color;
      this.size = random(2, 5);
      this.alpha = 255;
  }

  update() {
      this.vel.add(this.acc);
      this.pos.add(this.vel);
      this.alpha -= 5;
  }

  draw() {
      noStroke();
      fill(this.color[0], this.color[1], this.color[2], this.alpha);
      ellipse(this.pos.x, this.pos.y, this.size, this.size);
  }
}
